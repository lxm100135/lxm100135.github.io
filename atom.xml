<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simon&#39;s 博客</title>
  
  <subtitle>随性但不任性</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://simonlee.top/"/>
  <updated>2019-02-17T12:52:57.163Z</updated>
  <id>https://simonlee.top/</id>
  
  <author>
    <name>Simon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker操作</title>
    <link href="https://simonlee.top/2018/02/14/docker/"/>
    <id>https://simonlee.top/2018/02/14/docker/</id>
    <published>2018-02-14T09:25:12.000Z</published>
    <updated>2019-02-17T12:52:57.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><p>1安装环境说明<br>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>使用yum命令在线安装</p><pre><code>yum install docker</code></pre><p>安装后查看Docker版本<br>docker -v</p><h2 id="启动与停止Docker"><a href="#启动与停止Docker" class="headerlink" title="启动与停止Docker"></a>启动与停止Docker</h2><p>systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合。<br>l  启动docker：systemctl start docker<br>l  停止docker：systemctl stop docker<br>l  重启docker：systemctl restart docker<br>l  查看docker状态：systemctl status docker<br>l  开机启动：systemctl enable docker<br>l  查看docker概要信息：docker info<br>l  查看docker帮助文档：docker –help</p><h1 id="Docker镜像操作-列出镜像"><a href="#Docker镜像操作-列出镜像" class="headerlink" title="Docker镜像操作-列出镜像"></a>Docker镜像操作-列出镜像</h1><h2 id="1什么是Docker镜像"><a href="#1什么是Docker镜像" class="headerlink" title="1什么是Docker镜像"></a>1什么是Docker镜像</h2><p>Docker镜像是由文件系统叠加而成（是一种文件的存储形式）。最底端是一个文件引导系统，即bootfs，这很像典型的Linux/Unix的引导文件系统。Docker用户几乎永远不会和引导系统有什么交互。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要的一些文件，而这些文件就可以称为Docker镜像。</p><h2 id="2列出docker下的所有镜像：docker-images"><a href="#2列出docker下的所有镜像：docker-images" class="headerlink" title="2列出docker下的所有镜像：docker images"></a>2列出docker下的所有镜像：docker images</h2><p>l  REPOSITORY：镜像所在的仓库名称<br>l  TAG：镜像标签<br>l  IMAGE ID：镜像ID<br>l  CREATED：镜像的创建日期（不是获取该镜像的日期）<br>l  SIZE：镜像大小<br>l  这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h2 id="3镜像位置"><a href="#3镜像位置" class="headerlink" title="3镜像位置"></a>3镜像位置</h2><p>/var/lib/docker</p><h1 id="Docker镜像操作-搜索镜像"><a href="#Docker镜像操作-搜索镜像" class="headerlink" title="Docker镜像操作-搜索镜像"></a>Docker镜像操作-搜索镜像</h1><p>docker search 镜像名称<br> NAME：仓库名称<br> DESCRIPTION：镜像描述<br> STARS：用户评价，反应一个镜像的受欢迎程度<br> OFFICIAL：是否官方<br> AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h1 id="Docker镜像操作-拉取镜像"><a href="#Docker镜像操作-拉取镜像" class="headerlink" title="Docker镜像操作-拉取镜像"></a>Docker镜像操作-拉取镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><p>目前国内访问docker hub速度上有点尴尬，使用docker Mirror势在必行。现有国内提供docker镜像加速服务的商家有不少，下面重点ustc镜像。</p><h2 id="ustc的镜像"><a href="#ustc的镜像" class="headerlink" title="ustc的镜像"></a>ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。<br><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a><br>步骤：<br>（1）编辑该文件：vi /etc/docker/daemon.json  // 如果该文件不存在就手动创建；说明：在centos7.x下，通过vi。<br>（2）在该文件中输入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]&#125;</span><br></pre></td></tr></table></figure></p><p>（3）注意：一定要重启docker服务</p><p>然后通过docker pull命令下载镜像：速度得到提升</p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>1、  docker rmi $IMAGE_ID：删除指定镜像（可以是id或名字）<br>2、  docker rmi <code>docker images -q</code>：删除所有镜像（docker images -q所有镜像id）</p><h1 id="Docker容器操作-查看容器"><a href="#Docker容器操作-查看容器" class="headerlink" title="Docker容器操作-查看容器"></a>Docker容器操作-查看容器</h1><p>查看正在运行容器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></p><p>查看所有的容器（启动过的历史容器）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure></p><p>查看最后一次运行的容器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure></p><p>查看停止的容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure></p><h1 id="Docker容器操作-创建与启动容器"><a href="#Docker容器操作-创建与启动容器" class="headerlink" title="Docker容器操作-创建与启动容器"></a>Docker容器操作-创建与启动容器</h1><p>l  创建容器常用的参数说明：<br>l  创建容器命令：docker run<br>l  -i：表示运行容器<br>l  -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br>l  –name :为创建的容器命名。（–name=）<br>l  -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。<br>l  -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。<br>l  -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</p><h2 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h2><p>创建一个交互式容器并取名为mycentos（/bin/bash命令行）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=mycentos centos:7 /bin/bash</span><br></pre></td></tr></table></figure></p><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态</p><p>使用exit命令 退出当前容器（关机）</p><h2 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h2><p>创建一个守护式容器：如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。命令如下（容器名称不能重复）：（启动不需要命令行）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mycentos2 centos:7</span><br></pre></td></tr></table></figure></p><p> 登录守护式容器方式：<br>docker exec -it container_name (或者 container_id)  /bin/bash（exit退出时，容器不会停止）</p><p>停止正在运行的容器：docker stop $CONTAINER_NAME/ID</p><p>启动已运行过的容器：docker start $CONTAINER_NAME/ID</p><h1 id="Docker容器操作-文件拷贝"><a href="#Docker容器操作-文件拷贝" class="headerlink" title="Docker容器操作-文件拷贝"></a>Docker容器操作-文件拷贝</h1><p>如果我们需要将文件拷贝到容器内可以使用cp命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure></p><p>也可以将文件从容器内拷贝出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure></p><p>对应容器需要启动着</p><h1 id="Docker容器操作-目录挂载"><a href="#Docker容器操作-目录挂载" class="headerlink" title="Docker容器操作-目录挂载"></a>Docker容器操作-目录挂载</h1><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p><p>创建容器 添加-v参数 后边为   宿主机目录:容器目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /usr/<span class="built_in">local</span>/myhtml:/usr/<span class="built_in">local</span>/myhtml --name=mycentos2 centos:7</span><br></pre></td></tr></table></figure></p><p>如果你共享的是多级的目录，可能会出现权限不足的提示。<br>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题（一层没关系）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=mycentos2 -v /usr/<span class="built_in">local</span>/myhtml/:/usr/<span class="built_in">local</span>/mm --privileged=<span class="literal">true</span> centos:7</span><br></pre></td></tr></table></figure></p><p>查看容器IP地址<br>我们可以通过以下命令查看容器运行的各种数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect mycentos2</span><br></pre></td></tr></table></figure></p><p>也可以直接执行下面的命令直接输出IP地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> mycentos2</span><br></pre></td></tr></table></figure></p><h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm <span class="variable">$CONTAINER_ID</span>/NAME</span><br></pre></td></tr></table></figure><p>注意，只能删除停止的容器</p><p>删除所有容器：docker rm <code>docker ps -a -q</code>（docker ps -a -q得到所有容器id）</p><h1 id="容器部署"><a href="#容器部署" class="headerlink" title="容器部署"></a>容器部署</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>拉取MySQL镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure></p><p>创建MySQL容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=pinyougou_mysql -e MYSQL_ROOT_PASSWORD=123456 -p 33306:3306 mysql:latest</span><br></pre></td></tr></table></figure></p><p>e 代表添加环境变量  MYSQL_ROOT_PASSWORD是root用户的登陆密码<br>-p端口映射（宿主机:容器）<br>:latest可省略<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span>  -it pinyougou_mysql /bin/bash进入交互式容器</span><br><span class="line">mysql -uroot -p123456进入mysql</span><br></pre></td></tr></table></figure></p><p>windows通过宿主机（33306）成功连接容器中的mysql（3306）</p><h2 id="nginx容器部署"><a href="#nginx容器部署" class="headerlink" title="nginx容器部署"></a>nginx容器部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name pinyougou_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>配置反向代理<br>官方的nginx镜像,nginx配置文件nginx.conf 在/etc/nginx/目录下。<br>在容器内编辑配置文件不方便，我们可以先将配置文件从容器内拷贝到宿主机，编辑修改后再拷贝回去。<br>（1）从容器拷贝配置文件到宿主机<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp pinyougou_nginx:/etc/nginx/nginx.conf nginx.conf</span><br></pre></td></tr></table></figure></p><p>（2）编辑nginx.conf，添加反向代理配置<br>upstream tomcat-cas {        server 172.17.0.4:8080;<br>}<br>server {<br>listen 80;        server_name passport.pinyougou.com;<br>        location / {            proxy_pass <a href="http://tomcat-cas" target="_blank" rel="noopener">http://tomcat-cas</a>;<br>        index index.html index.htm;<br>        }<br>    }<br>（3）将修改后的配置文件拷贝到容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx.conf  pinyougou_nginx:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></p><p>（4）重新启动容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart pinyougou_nginx</span><br></pre></td></tr></table></figure></p><p>（5）设置域名指向<br>192.168.247.135 passport.pinyougou.com<br>浏览器测试：<a href="http://passport.pinyougou.com/cas/login" target="_blank" rel="noopener">http://passport.pinyougou.com/cas/login</a></p><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>拉取Redis镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></p><p>创建Redis容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=pinyougou_redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></p><p> 客户端测试<br>在你的本地电脑命令提示符下，用window版本redis测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.247.135</span><br></pre></td></tr></table></figure></p><h1 id="备份与迁移"><a href="#备份与迁移" class="headerlink" title="备份与迁移"></a>备份与迁移</h1><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit pinyougou_nginx mynginx</span><br></pre></td></tr></table></figure></p><p>pinyougou_nginx是容器名称<br>mynginx是新的镜像名称<br>此镜像的内容就是你当前容器的内容，接下来你可以用此镜像再次运行新的容器</p><h2 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx</span><br></pre></td></tr></table></figure><p>-o 输出到的文件<br>执行后，运行ls命令即可看到打成的tar包</p><h2 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h2><p>首先我们先删除掉mynginx镜像<br>然后执行此命令进行恢复<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure></p><p>-i 输入的文件<br>执行后再次查看镜像，可以看到镜像已经恢复</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker安装与启动&quot;&gt;&lt;a href=&quot;#Docker安装与启动&quot; class=&quot;headerlink&quot; title=&quot;Docker安装与启动&quot;&gt;&lt;/a&gt;Docker安装与启动&lt;/h1&gt;&lt;p&gt;1安装环境说明&lt;br&gt;Docker官方建议在Ubuntu中安装，因为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络爬虫框架Webmagic</title>
    <link href="https://simonlee.top/2018/01/14/hello-world/"/>
    <id>https://simonlee.top/2018/01/14/hello-world/</id>
    <published>2018-01-14T09:03:00.000Z</published>
    <updated>2019-02-22T14:29:40.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？"><a href="#我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？" class="headerlink" title="我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？"></a>我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？</h1><ul><li>可以实现搜索引擎</li><li>大数据时代，<br>可以让我们获取更多的数据源。</li><li>快速填充测试和运营数据</li><li>为人工智能提供训练数据集</li></ul><h2 id="爬取页面全部内容"><a href="#爬取页面全部内容" class="headerlink" title="爬取页面全部内容"></a>爬取页面全部内容</h2><p><a href="https://blog.csdn.net/nav/ai" target="_blank" rel="noopener">https://blog.csdn.net/nav/ai</a></p><p>（1）创建工程，引入依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;webmagic-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;us.codecraft&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.7.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>（2）编写类实现网页内容的爬取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxm.demo;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Page;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Site;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Spider;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.processor.PageProcessor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 爬取类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line">System.out.println(page.getHtml().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Site.me().setSleepTime(<span class="number">100</span>).setRetryTimes(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor()</span><br><span class="line">).addUrl(<span class="string">"https://blog.csdn.net"</span>).run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spider是爬虫启动的入口。在启动爬虫之前，我们需要使用一个PageProcessor创建<br>一个Spider对象，然后使用run()进行启动。<br><img src="http://pn5tkreux.bkt.clouddn.com/1550827500412vlh3apt6.png?imageslim" alt="paste image"><br><img src="http://pn5tkreux.bkt.clouddn.com/1550827773318nrfa5p8x.png?imageslim" alt="paste image"></p><h2 id="爬取指定内容（XPath）"><a href="#爬取指定内容（XPath）" class="headerlink" title="爬取指定内容（XPath）"></a>爬取指定内容（XPath）</h2><p>我们通过指定xpath来抓取网页的部分内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(page.getHtml().xpath(<span class="string">"//*</span></span><br><span class="line"><span class="string">[@id=\"nav\"]/div/div/ul/li[5]/a"</span>).toString());</span><br></pre></td></tr></table></figure></p><h2 id="添加目标地址"><a href="#添加目标地址" class="headerlink" title="添加目标地址"></a>添加目标地址</h2><p>需求：只提取播客的文章详细页内容，并提取标题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxm.demo;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Page;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Site;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Spider;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.processor.PageProcessor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 爬取类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line"><span class="comment">//page.addTargetRequests( page.getHtml().links().all() );//将当前页</span></span><br><span class="line">面里的所有链接都添加到目标页面中</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">page.addTargetRequests(</span><br><span class="line">page.getHtml().links().regex(<span class="string">"https://blog.csdn.net/[a‐z 0‐9</span></span><br><span class="line"><span class="string">‐]+/article/details/[0‐9]&#123;8&#125;"</span>).all() );</span><br><span class="line">System.out.println(page.getHtml().xpath(<span class="string">"//*</span></span><br><span class="line"><span class="string">[@id=\"mainBox\"]/main/div[1]/div[1]/h1/text()"</span>).toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Site.me().setSleepTime(<span class="number">100</span>).setRetryTimes(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor()</span><br><span class="line">).addUrl(<span class="string">"https://blog.csdn.net/nav/ai"</span>).run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><h2 id="ConsolePipeline-控制台输出"><a href="#ConsolePipeline-控制台输出" class="headerlink" title="ConsolePipeline 控制台输出"></a>ConsolePipeline 控制台输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 爬取类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">implements</span> <span class="title">PageProcessor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Page page)</span> </span>&#123;</span><br><span class="line"><span class="comment">//page.addTargetRequests( page.getHtml().links().all() );//将当前页</span></span><br><span class="line">面里的所有链接都添加到目标页面中</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">page.addTargetRequests(</span><br><span class="line">page.getHtml().links().regex(<span class="string">"https://blog.csdn.net/[a‐z 0‐9</span></span><br><span class="line"><span class="string">‐]+/article/details/[0‐9]&#123;8&#125;"</span>).all() );</span><br><span class="line"><span class="comment">//System.out.println(page.getHtml().xpath("//*</span></span><br><span class="line">[<span class="meta">@id</span>=\<span class="string">"mainBox\"]/main/div[1]/div[1]/h1/text()"</span>).toString());</span><br><span class="line">page.putField(<span class="string">"title"</span>,page.getHtml().xpath(<span class="string">"//*</span></span><br><span class="line"><span class="string">[@id=\"mainBox\"]/main/div[1]/div[1]/h1/text()"</span>).toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Site <span class="title">getSite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Site.me().setSleepTime(<span class="number">100</span>).setRetryTimes(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line">.addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FilePipeline-文件保存"><a href="#FilePipeline-文件保存" class="headerlink" title="FilePipeline 文件保存"></a>FilePipeline 文件保存</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line">.addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">.addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"e:/data"</span>))<span class="comment">//以文件方式保存</span></span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JsonFilePipeline"><a href="#JsonFilePipeline" class="headerlink" title="JsonFilePipeline"></a>JsonFilePipeline</h1><p>以json方式保存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line">.addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">.addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"e:/data"</span>))</span><br><span class="line">.addPipeline(<span class="keyword">new</span> JsonFilePipeline(<span class="string">"e:/json"</span>))<span class="comment">// 以json方式保</span></span><br><span class="line">存</span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="定制Pipeline"><a href="#定制Pipeline" class="headerlink" title="定制Pipeline"></a>定制Pipeline</h1><p>如果以上Pipeline都不能满足你的需要，你可以定制Pipeline<br>（1）创建类MyPipeline实现接口Pipeline<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.ResultItems;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.Task;</span><br><span class="line"><span class="keyword">import</span> us.codecraft.webmagic.pipeline.Pipeline;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPipeline</span> <span class="keyword">implements</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ResultItems resultItems, Task task)</span> </span>&#123;</span><br><span class="line">String title=resultItems.get(<span class="string">"title"</span>);</span><br><span class="line">System.out.println(<span class="string">"我的定制的 title:"</span>+title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）修改main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line">.addPipeline(<span class="keyword">new</span> ConsolePipeline())</span><br><span class="line">.addPipeline(<span class="keyword">new</span> FilePipeline(<span class="string">"e:/data"</span>))</span><br><span class="line">.addPipeline(<span class="keyword">new</span> JsonFilePipeline(<span class="string">"e:/json"</span>))</span><br><span class="line">.addPipeline(<span class="keyword">new</span> MyPipeline())<span class="comment">//定制化输出</span></span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>我们刚才完成的功能，每次运行可能会爬取重复的页面，这样做是没有任何意义的。<br>Scheduler(URL管理) 最基本的功能是实现对已经爬取的URL进行标示。可以实现URL的增<br>量去重。<br>目前scheduler主要有三种实现方式：<br>1）内存队列 QueueScheduler<br>2）文件队列 FileCacheQueueScheduler<br>3) Redis队列 RedisScheduler</p><h2 id="内存队列"><a href="#内存队列" class="headerlink" title="内存队列"></a>内存队列</h2><p>使用setScheduler来设置Scheduler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line">.setScheduler(<span class="keyword">new</span> QueueScheduler())</span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="文件队列"><a href="#文件队列" class="headerlink" title="文件队列"></a>文件队列</h2><p>使用文件保存抓取URL，可以在关闭程序并下次启动时，从之前抓取到的URL继续抓取<br>（1）创建文件夹E:\scheduler<br>（2）修改代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line"><span class="comment">//.setScheduler(new QueueScheduler())//设置内存队列</span></span><br><span class="line">.setScheduler(<span class="keyword">new</span></span><br><span class="line">FileCacheQueueScheduler(<span class="string">"E:\\scheduler"</span>))<span class="comment">//设置文件队列</span></span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后文件夹E:\scheduler会产生两个文件blog.csdn.net.urls.txt和<br>blog.csdn.net.cursor.txt</p><h2 id="Redis队列"><a href="#Redis队列" class="headerlink" title="Redis队列"></a>Redis队列</h2><p>使用Redis保存抓取队列，可进行多台机器同时合作抓取<br>（1）运行redis服务端<br>（2）修改代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Spider.create( <span class="keyword">new</span> MyProcessor() )</span><br><span class="line">.addUrl(<span class="string">"https://blog.csdn.net"</span>)</span><br><span class="line"><span class="comment">//.setScheduler(new QueueScheduler())//设置内存队列</span></span><br><span class="line"><span class="comment">//.setScheduler(new</span></span><br><span class="line">FileCacheQueueScheduler(<span class="string">"E:\\scheduler"</span>))<span class="comment">//设置文件队列</span></span><br><span class="line">.setScheduler(<span class="keyword">new</span> RedisScheduler(<span class="string">"127.0.0.1"</span>))<span class="comment">//设置Redis队</span></span><br><span class="line">列</span><br><span class="line">.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？&quot;&gt;&lt;a href=&quot;#我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？&quot; class=&quot;headerlink&quot; title=&quot;我们初步认识了网络爬虫，网络爬虫具体可以做什么呢？&quot;&gt;&lt;/a&gt;我们初步认识了网络爬虫
      
    
    </summary>
    
    
  </entry>
  
</feed>
